<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Getting Started on OpenTestingAPI</title><link>https://opentestingapi.github.io/getting-started/</link><description>Recent content in Getting Started on OpenTestingAPI</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://opentestingapi.github.io/getting-started/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction</title><link>https://opentestingapi.github.io/getting-started/10_introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://opentestingapi.github.io/getting-started/10_introduction/</guid><description>A typical modern application development:
A modern architectures is often build of several (up to hundreds) of connected services with huge amount of different technologies for communication and persistence Typical system- and integration test are build by developers using the technology, which is the base for the service implementation. In best case End-to-End testing (E2E) is done by dedicated testers using standard tools sticking to a few technologies. Typical E2E Tests are one time shots: Start, Run, Destroy Drawbacks of the current approach:</description></item><item><title>End-To-End Testing</title><link>https://opentestingapi.github.io/getting-started/20_e2etesting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://opentestingapi.github.io/getting-started/20_e2etesting/</guid><description>Testing End-to-End (E2E) testing describes an approach which tests a system from its beginning to its end. Each software system has at least one mission. The system is taking input data, processes this data and generates some output data. It&amp;rsquo;s as simple - really. A system without these simple steps is a system without a mission - it&amp;rsquo;s a useless system.
Processing can be quite simple, take data from a place and put it to another one.</description></item><item><title>Why a Testing API?</title><link>https://opentestingapi.github.io/getting-started/30_whyanapi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://opentestingapi.github.io/getting-started/30_whyanapi/</guid><description>A new project results in a new testing approach, depending on the used technology and the people working. Someone has experience with tool X, another one has already licenses for tool Y and another project member likes to approach to do everything from the scratch and new. In best case you can find a common solution fitting all your requirements to develop a good test practice. In worst case you find a huge set of tests, which can not be executed or further improvement results in huge efforts.</description></item><item><title>Hello World</title><link>https://opentestingapi.github.io/getting-started/40_hello-world/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://opentestingapi.github.io/getting-started/40_hello-world/</guid><description>Let&amp;rsquo;s start with a simple test case example. In general a testcase consist of 2 sections, a section describing the input for our system under test (SUT) and a section describing the output validation. In addition, a few meta information to identify the test case has to be added. With this, a minimal test cases frame looks like:
{ &amp;#34;testapi&amp;#34;: &amp;#34;0.1&amp;#34;, &amp;#34;id&amp;#34;: &amp;#34;hello_world_test&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;my first hello world test, showing how its working&amp;#34;, &amp;#34;injections&amp;#34;: [ .</description></item></channel></rss>